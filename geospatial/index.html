<!DOCTYPE html>
<html>
<head>
    <title>Firebolt Geospatial Demo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/sql/sql.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            background-color: #f8f9fa;
            color: #333;
        }
        .CodeMirror {
            height: 100px;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 13px;
            resize: vertical;
            overflow: auto;
        }
        .CodeMirror-wrap {
            resize: vertical;
            overflow: hidden;
            min-height: 50px;
        }
        .CodeMirror::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            cursor: se-resize;
            background: 
                linear-gradient(135deg, transparent 50%, #ccc 50%),
                linear-gradient(45deg, #ccc 50%, transparent 50%);
            background-size: 50% 50%;
            background-position: 100% 100%;
            background-repeat: no-repeat;
            opacity: 0.5;
        }
        #results {
            margin-top: 15px;
            overflow-x: auto;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            border: 1px solid #e1e4e8;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 0;
        }
        th, td {
            border: 1px solid #e1e4e8;
            padding: 6px 10px;
            text-align: left;
            font-size: 13px;
        }
        th {
            background-color: #f6f8fa;
            font-weight: 500;
            color: #57606a;
        }
        tr:nth-child(even) {
            background-color: #fafbfc;
        }
        tr:hover {
            background-color: #f6f8fa;
        }
        #map {
            width: 100%;
            height: 400px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #e1e4e8;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: block;
        }
        .map-container {
            margin-bottom: 15px;
        }
        .query-controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            background: #fff;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e1e4e8;
        }
        .control-group {
            flex: 1;
            min-width: 200px;
            max-width: 500px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e1e4e8;
            position: relative;
        }
        .group-title {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #24292e;
            font-weight: 500;
            padding-bottom: 5px;
            border-bottom: 1px solid #e1e4e8;
        }
        .input-group {
            margin-top: 8px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .checkbox-group input[type="checkbox"] {
            margin: 0;
        }
        .checkbox-group label {
            font-size: 13px;
            color: #24292e;
            line-height: 1.2;
        }
        .input-label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #57606a;
        }
        .number-input {
            width: calc(100% - 16px);
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }
        button {
            width: 100%;
            margin-bottom: 4px;
            box-sizing: border-box;
        }
        button:hover {
            background-color: #f3f4f6;
            border-color: #b1b5bb;
        }
        button.primary {
            background-color: #ed262c;
            color: white;
            border-color: #ed262c;
        }
        button.primary:hover {
            background-color: #d61f24;
            border-color: #d61f24;
        }
        input[type="number"] {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            color: #24292e;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #ed262c;
            box-shadow: 0 0 0 2px rgba(237,38,44,0.1);
        }
        h1 {
            color: #24292e;
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: 500;
            border-bottom: 2px solid #ed262c;
            padding-bottom: 6px;
        }
        .stats {
            background: #f6f8fa;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 15px;
            border: 1px solid #e1e4e8;
            font-size: 12px;
        }
        .stats h3 {
            color: #24292e;
            margin-top: 0;
            margin-bottom: 6px;
            font-size: 13px;
            font-weight: 500;
        }
        .stats p {
            margin: 3px 0;
            color: #57606a;
        }
        .info-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e1e4e8;
            color: #57606a;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            cursor: help;
            font-weight: bold;
        }

        .tooltip {
            position: static;
            display: block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            background-color: #24292e;
            color: #fff;
            text-align: left;
            padding: 8px 12px;
            border-radius: 4px;
            position: absolute;
            z-index: 1000;
            width: 220px;
            top: 30px;
            right: 0;
            transform: none;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
        }

        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #24292e transparent;
        }

        .query-execution {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            position: relative;
        }

        .query-execution button {
            margin: 0;
            flex: 1;
            padding: 6px 12px;
        }

        .query-execution .info-icon {
            position: static;
            display: inline-block;
        }

        .query-execution .tooltip .tooltip-text {
            width: 300px;
            top: 50%;
            right: 100%;
            left: auto;
            transform: translateY(-50%);
            margin-right: 10px;
        }

        .query-execution .tooltip .tooltip-text::after {
            top: 50%;
            right: -10px;
            bottom: auto;
            transform: translateY(-50%);
            border-color: transparent transparent transparent #24292e;
        }

        .query-execution .tooltip {
            flex: 0 0 auto;
            position: relative;
        }

        .loading-message {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            padding: 8px;
            margin-top: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: #24292e;
            font-size: 14px;
            text-align: center;
            z-index: 1000;
            border: 1px solid #e1e4e8;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #queryInput {
            margin-bottom: 15px;
        }

        .title-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .title-container h1 {
            margin: 0;
        }

        .title-container .info-icon {
            position: static;
            display: inline-block;
            top: auto;
            right: auto;
        }

        .title-container .tooltip {
            position: relative;
        }

        .title-container .tooltip .tooltip-text {
            width: 400px;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <h1>Firebolt Geospatial Demo</h1>
        <div class="tooltip">
            <span class="info-icon">i</span>
            <span class="tooltip-text">
                This AI-generated web application demonstrates Firebolt's geospatial capabilities using the <a href="https://www.kaggle.com/datasets/sobhanmoosavi/us-accidents" target="_blank" style="color: #58a6ff; text-decoration: underline;">US Accidents Dataset (2016-2023)</a> from Kaggle, containing accident records across 49 states. The data is stored in the usaccidentdata table, where accident locations are represented using GEOGRAPHY data type in the start_location and end_location columns. You can find more details about how the data was processed in the <a href="https://github.com/firebolt-db/firebolt-demo/tree/main/geospatial" target="_blank" style="color: #58a6ff; text-decoration: underline;">GitHub repository</a>.
            </span>
        </div>
    </div>
    <div id="queryInput"></div>
    <div class="query-execution">
        <button id="executeButton" class="primary" onclick="executeQuery()">
            Execute Query
        </button>
        <div id="loadingMessage" class="loading-message" style="display: none;">
            Executing query... This may take a while if the Firebolt Engine needs to be started first.
        </div>
        <div class="tooltip">
            <span class="info-icon">i</span>
            <span class="tooltip-text">
                All query results are displayed in a table below. When the first column contains GeoJSON data, it will be visualized on the map. If there is a second column, its values will determine the colors of the markers on the map. Additionally, any GeoJSON or WKT geometries found in the query text will be shown on the map in red.
            </span>
        </div>
    </div>
    
    <div class="map-container">
        <div id="map"></div>
        <div class="query-controls">
            <!-- Polygon Query Group -->
            <div class="control-group">
                <div class="tooltip">
                    <h4 class="group-title">Polygon Query</h4>
                    <span class="info-icon">i</span>
                    <span class="tooltip-text">Selects all accidents with a start location within a polygon drawn on the map. Draw a polygon to define your area of interest.</span>
                </div>
                <button onclick="queryWithPolygon()">Query with Polygon</button>
            </div>

            <!-- Nearest Points Group -->
            <div class="control-group">
                <div class="tooltip">
                    <h4 class="group-title">Nearest Points</h4>
                    <span class="info-icon">i</span>
                    <span class="tooltip-text">Finds the nearest accident locations to a point you select on the map. Draw a point to find accidents closest to that location.</span>
                </div>
                <button onclick="queryNearestPoints()">Find Nearest Points</button>
                <div class="input-group">
                    <label class="input-label">Number of points</label>
                    <input type="number" id="numPoints" class="number-input" value="10" min="1">
                </div>
            </div>

            <!-- LineString Query Group -->
            <div class="control-group">
                <div class="tooltip">
                    <h4 class="group-title">LineString Query</h4>
                    <span class="info-icon">i</span>
                    <span class="tooltip-text">Finds accidents within a specified distance from a line drawn on the map. Useful for finding accidents along a route or corridor.</span>
                </div>
                <button onclick="queryWithLineString()">Query with LineString</button>
                <div class="input-group">
                    <label class="input-label">Max distance (meters)</label>
                    <input type="number" id="maxDistance" class="number-input" value="10" min="1">
                </div>
                <div class="input-group checkbox-group">
                    <input type="checkbox" id="useOptimization" unchecked>
                    <label for="useOptimization">Use bounding box optimization</label>
                </div>
            </div>
        </div>
    </div>
    
    <div id="results"></div>

    <script>
        const map = L.map('map').setView([37.8, -96], 4);  // Center on US
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const editor = CodeMirror(document.getElementById('queryInput'), {
            mode: 'text/x-sql',
            lineNumbers: true,
            autofocus: true,
            lineWrapping: true,
            tabSize: 2,
            extraKeys: {
                'Ctrl-Enter': executeQuery,
                'Cmd-Enter': executeQuery
            }
        });

        editor.setValue(`select st_asgeojson(start_location) from usaccidentdata where st_covers('POLYGON((-73.95826578140259 40.80120581546623,-73.94845962524414 40.79711243898632,-73.97289991378783 40.76401504612403,-73.98268461227417 40.76785044388771,-73.95826578140259 40.80120581546623))', start_location);`);

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        const drawControl = new L.Control.Draw({
            draw: {
                polygon: true,
                marker: true,
                polyline: true,  // Enable linestring drawing
                circle: false,
                circlemarker: false,
                rectangle: false
            },
            edit: {
                featureGroup: drawnItems
            }
        });
        map.addControl(drawControl);

        let geoJsonLayer = null;
        let queryGeometryLayers = [];
        let currentPolygon = null;
        let currentPoint = null;
        let currentLineString = null;
        let s2CoveringLayer = null;

        map.on(L.Draw.Event.CREATED, function (e) {
            drawnItems.clearLayers();
            let layer = e.layer;
            
            // Get the GeoJSON representation of the drawn shape
            const geoJSON = layer.toGeoJSON();
            
            // Apply tessellation if it's a polygon or linestring (for display only)
            if (geoJSON.geometry.type === 'Polygon' || geoJSON.geometry.type === 'LineString') {
                const tessellatedGeometry = tessellateGeometry(geoJSON.geometry);
                // Create a new layer with the tessellated geometry and add it directly
                drawnItems.addLayer(L.geoJSON(tessellatedGeometry, {
                    style: {
                        color: '#3388ff',  // Default Leaflet blue color
                        weight: 3,
                        opacity: 1
                    }
                }));
                
                // Store the original layer for queries but use tessellated version for display
                if (geoJSON.geometry.type === 'Polygon') {
                    currentPolygon = layer;  // Store original
                } else if (geoJSON.geometry.type === 'LineString') {
                    currentLineString = layer;  // Store original
                }
            } else {
                drawnItems.addLayer(layer);
                if (geoJSON.geometry.type === 'Point') {
                    currentPoint = layer;
                }
            }
            
            // Clear other current shape references
            if (geoJSON.geometry.type === 'Polygon') {
                currentPoint = null;
                currentLineString = null;
            } else if (geoJSON.geometry.type === 'Point') {
                currentPolygon = null;
                currentLineString = null;
            } else if (geoJSON.geometry.type === 'LineString') {
                currentPoint = null;
                currentPolygon = null;
            }
        });

        map.on('draw:deleted', function(e) {
            currentPolygon = null;
            currentPoint = null;
            currentLineString = null;
        });

        async function queryNearestPoints() {
            if (!currentPoint) {
                alert('Please draw a point first');
                return;
            }

            const pointGeoJSON = currentPoint.toGeoJSON().geometry;
            const numPoints = document.getElementById('numPoints').value || 10;

            const query = `select st_asgeojson(start_location) from usaccidentdata order by st_distance('${JSON.stringify(pointGeoJSON)}', start_location) limit ${numPoints};`;
            
            editor.setValue(query);
            await executeQuery();
        }

        async function queryWithPolygon() {
            if (!currentPolygon) {
                alert('Please draw a polygon first');
                return;
            }

            // Debug logging
            console.log('Current Polygon:', currentPolygon);
            console.log('GeoJSON:', currentPolygon.toGeoJSON());
            
            // If currentPolygon is a GeoJSON layer, we need to get its first feature's geometry
            let polygonGeoJSON;
            if (currentPolygon instanceof L.GeoJSON) {
                polygonGeoJSON = currentPolygon.toGeoJSON().features[0].geometry;
            } else {
                polygonGeoJSON = currentPolygon.toGeoJSON().geometry;
            }
            
            console.log('Final Geometry:', polygonGeoJSON);

            const query = `select st_asgeojson(start_location) from usaccidentdata where st_covers('${JSON.stringify(polygonGeoJSON)}', start_location);`;
            
            editor.setValue(query);
            await executeQuery();
        }

        async function queryWithLineString() {
            if (!currentLineString) {
                alert('Please draw a line first');
                return;
            }

            // If currentLineString is a GeoJSON layer, we need to get its first feature's geometry
            let lineStringGeoJSON;
            if (currentLineString instanceof L.GeoJSON) {
                lineStringGeoJSON = currentLineString.toGeoJSON().features[0].geometry;
            } else {
                lineStringGeoJSON = currentLineString.toGeoJSON().geometry;
            }

            const maxDistance = document.getElementById('maxDistance').value || 1000;
            const useOptimization = document.getElementById('useOptimization').checked;
            
            let query;
            
            if (useOptimization) {
                // Get coordinates from linestring
                const coordinates = lineStringGeoJSON.coordinates;
                
                // Calculate bounding box
                let minLat = Infinity, maxLat = -Infinity;
                let minLng = Infinity, maxLng = -Infinity;
                
                coordinates.forEach(coord => {
                    minLng = Math.min(minLng, coord[0]);
                    maxLng = Math.max(maxLng, coord[0]);
                    minLat = Math.min(minLat, coord[1]);
                    maxLat = Math.max(maxLat, coord[1]);
                });
                
                // Add buffer to bounding box (approximately maxDistance meters)
                const latBuffer = maxDistance / 111000;
                const lngBuffer = maxDistance / (111000 * Math.cos(((minLat + maxLat) / 2) * Math.PI / 180));
                
                // Create bounding box polygon
                const boundingBox = `POLYGON((
                    ${minLng - lngBuffer} ${minLat - latBuffer},
                    ${minLng - lngBuffer} ${maxLat + latBuffer},
                    ${maxLng + lngBuffer} ${maxLat + latBuffer},
                    ${maxLng + lngBuffer} ${minLat - latBuffer},
                    ${minLng - lngBuffer} ${minLat - latBuffer}
                ))`;

                query = `SELECT st_asgeojson(start_location) 
                        FROM usaccidentdata 
                        WHERE CASE 
                            WHEN st_intersects('${boundingBox}', start_location) 
                            THEN st_distance('${JSON.stringify(lineStringGeoJSON)}', start_location) <= ${maxDistance}
                            ELSE false 
                        END;`;
            } else {
                query = `SELECT st_asgeojson(start_location) 
                        FROM usaccidentdata 
                        WHERE st_distance('${JSON.stringify(lineStringGeoJSON)}', start_location) <= ${maxDistance};`;
            }
            
            editor.setValue(query);
            await executeQuery();
        }

        function tessellateLineSegment(start, end, numPoints = null) {
            const points = [];
            const lat1 = start[1] * Math.PI / 180;
            const lon1 = start[0] * Math.PI / 180;
            const lat2 = end[1] * Math.PI / 180;
            const lon2 = end[0] * Math.PI / 180;
            
            const d = 2 * Math.asin(Math.sqrt(
                Math.pow(Math.sin((lat2 - lat1) / 2), 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin((lon2 - lon1) / 2), 2)
            )) * 180 / Math.PI;
            
            if (numPoints === null) {
                numPoints = Math.max(1000, Math.ceil(d * 5));
            }
            
            for (let i = 0; i <= numPoints; i++) {
                const f = i / numPoints;
                
                const A = Math.sin((1 - f) * d * Math.PI / 180) / Math.sin(d * Math.PI / 180);
                const B = Math.sin(f * d * Math.PI / 180) / Math.sin(d * Math.PI / 180);
                
                const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
                const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
                const z = A * Math.sin(lat1) + B * Math.sin(lat2);
                
                const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
                const lon = Math.atan2(y, x);
                
                points.push([lon * 180 / Math.PI, lat * 180 / Math.PI]);
            }
            return points;
        }

        function tessellateGeometry(geometry) {
            if (geometry.type === 'Polygon') {
                return {
                    type: 'Polygon',
                    coordinates: geometry.coordinates.map(ring => {
                        const tessellatedRing = [];
                        for (let i = 0; i < ring.length - 1; i++) {
                            const points = tessellateLineSegment(ring[i], ring[i + 1]);
                            tessellatedRing.push(...points.slice(0, -1));
                        }
                        tessellatedRing.push(ring[ring.length - 1]);
                        return tessellatedRing;
                    })
                };
            } else if (geometry.type === 'LineString') {
                const tessellatedLine = [];
                for (let i = 0; i < geometry.coordinates.length - 1; i++) {
                    const points = tessellateLineSegment(geometry.coordinates[i], geometry.coordinates[i + 1]);
                    tessellatedLine.push(...points.slice(0, -1));
                }
                tessellatedLine.push(geometry.coordinates[geometry.coordinates.length - 1]);
                
                return {
                    type: 'LineString',
                    coordinates: tessellatedLine
                };
            }
            return geometry;
        }

        async function executeQuery() {
            const queryInput = editor.getValue();
            const resultsDiv = document.getElementById('results');
            const executeButton = document.getElementById('executeButton');
            const loadingMessage = document.getElementById('loadingMessage');
            
            // Show initial loading state (just the button)
            executeButton.innerHTML = '<span class="spinner"></span>Executing...';
            executeButton.disabled = true;
            
            // Start a timer
            const startTime = Date.now();
            let messageTimeout = setTimeout(() => {
                loadingMessage.style.display = 'block';
            }, 3000);
            
            // Clear all previous layers
            drawnItems.clearLayers();
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
                geoJsonLayer = null;  // Reset to null after removing
            }
            queryGeometryLayers.forEach(layer => map.removeLayer(layer));
            queryGeometryLayers = [];
            currentPolygon = null;
            currentPoint = null;
            currentLineString = null;
            
            try {
                const response = await fetch('https://api.staging.firebolt.io/demo/execute-query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: queryInput
                    })
                });
                
                const data = await response.json();
                
                if (data.errors) {
                    resultsDiv.innerHTML = `<p style="color: #ed262c; padding: 12px; background: #fff; border-radius: 4px; border: 1px solid #e1e4e8;">${data.errors[0].description}</p>`;
                    return;
                }

                // Add warning message if results are limited
                if (data.data.length >= 100) {
                    resultsDiv.innerHTML = `
                        <p style="color: #856404; background-color: #fff3cd; padding: 12px; border: 1px solid #ffeeba; border-radius: 4px; margin-bottom: 15px;">
                            <strong>Note:</strong> Query results are limited to 100 rows
                        </p>`;
                } else {
                    resultsDiv.innerHTML = '';
                }

                // Extract all WKT strings from the query
                const wktMatches = queryInput.match(/'(POLYGON|POINT|LINESTRING)\s*\([^']+\)'/g) || [];
                const geojsonMatches = queryInput.match(/'{\s*"type"\s*:\s*"[^}]+"[^']*}'/g) || [];
                
                // Convert WKT to GeoJSON and process geometries
                for (const match of [...wktMatches, ...geojsonMatches]) {
                    try {
                        let geometry;
                        if (match.startsWith("'POLYGON") || match.startsWith("'POINT") || match.startsWith("'LINESTRING")) {
                            // Convert WKT to GeoJSON using Firebolt
                            const wktResponse = await fetch('https://api.staging.firebolt.io/demo/execute-query', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    query: `SELECT st_asgeojson(${match})`
                                })
                            });
                            const wktData = await wktResponse.json();
                            if (!wktData.errors && wktData.data.length > 0) {
                                geometry = JSON.parse(wktData.data[0][0]);
                            }
                        } else {
                            // Parse GeoJSON directly
                            geometry = JSON.parse(match.slice(1, -1));
                        }
                        
                        // Add to map in red and track the layer
                        if (geometry) {
                            // Apply tessellation to all geometries
                            if (geometry.type === 'Polygon' || geometry.type === 'LineString') {
                                geometry = tessellateGeometry(geometry);
                            } else if (geometry.type === 'Feature') {
                                if (geometry.geometry.type === 'Polygon' || geometry.geometry.type === 'LineString') {
                                    geometry.geometry = tessellateGeometry(geometry.geometry);
                                }
                            } else if (geometry.type === 'FeatureCollection') {
                                geometry.features = geometry.features.map(feature => {
                                    if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'LineString') {
                                        feature.geometry = tessellateGeometry(feature.geometry);
                                    }
                                    return feature;
                                });
                            }

                            const layer = L.geoJSON(geometry, {
                                style: {
                                    color: '#ff0000',
                                    weight: 2,
                                    opacity: 0.7,
                                    fillOpacity: 0.2
                                },
                                pointToLayer: function (feature, latlng) {
                                    return L.marker(latlng, {
                                        icon: new L.Icon({
                                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                                            iconSize: [25, 41],
                                            iconAnchor: [12, 41],
                                            popupAnchor: [1, -34],
                                            shadowSize: [41, 41]
                                        })
                                    });
                                }
                            }).addTo(map);
                            queryGeometryLayers.push(layer);
                        }
                    } catch (e) {
                        console.error('Failed to parse geometry:', e, match);
                    }
                }

                if (data.meta.length >= 2 && 
                    data.data.length > 0 && 
                    typeof data.data[0][0] === 'string' &&
                    (() => { try { JSON.parse(data.data[0][0]); return true; } catch { return false; }})()) {
                    
                    // Get unique values from the second column
                    const uniqueValues = [...new Set(data.data.map(row => row[1]))];
                    
                    // Use only colors that have corresponding markers
                    const colors = ['#2ca02c', '#d62728', '#1f77b4', '#ff7f0e', '#8c564b', '#7f7f7f', '#ffff00', '#4B0082'];
                    const markerColorMap = {
                        '#2ca02c': 'green',
                        '#d62728': 'red',
                        '#1f77b4': 'blue',
                        '#ff7f0e': 'orange',
                        '#8c564b': 'gold',
                        '#7f7f7f': 'grey',
                        '#ffff00': 'yellow',
                        '#4B0082': 'violet'
                    };
                    
                    // Generate a color for each unique value
                    const colorMap = {};
                    uniqueValues.forEach((value, index) => {
                        colorMap[value] = colors[index % colors.length];
                    });

                    // Process features with their assigned colors
                    const features = data.data.map(row => {
                        try {
                            let geojson = JSON.parse(row[0]);
                            
                            // Apply tessellation
                            if (geojson.type === 'Polygon' || geojson.type === 'LineString') {
                                geojson = tessellateGeometry(geojson);
                            } else if (geojson.type === 'Feature') {
                                if (geojson.geometry.type === 'Polygon' || geojson.geometry.type === 'LineString') {
                                    geojson.geometry = tessellateGeometry(geojson.geometry);
                                }
                            } else if (geojson.type === 'FeatureCollection') {
                                geojson.features = geojson.features.map(feature => {
                                    if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'LineString') {
                                        feature.geometry = tessellateGeometry(feature.geometry);
                                    }
                                    return feature;
                                });
                            }
                            
                            return {
                                geojson: geojson,
                                value: row[1]
                            };
                        } catch (e) {
                            console.error('Failed to parse row:', e);
                            return null;
                        }
                    }).filter(f => f !== null);
                    
                    // Add features to map with their assigned colors
                    features.forEach(({geojson, value}) => {
                        const layer = L.geoJSON(geojson, {
                            style: {
                                color: colorMap[value],
                                weight: 2,
                                opacity: 0.7,
                                fillOpacity: 0.4
                            },
                            pointToLayer: function (feature, latlng) {
                                const marker = L.marker(latlng, {
                                    icon: new L.Icon({
                                        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${markerColorMap[colorMap[value]]}.png`,
                                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                                        iconSize: [25, 41],
                                        iconAnchor: [12, 41],
                                        popupAnchor: [1, -34],
                                        shadowSize: [41, 41]
                                    })
                                });
                                const columnName = data.meta[1]?.name || 'Value';
                                marker.bindPopup(`${columnName}: ${value}`);
                                return marker;
                            },
                            onEachFeature: function(feature, layer) {
                                const columnName = data.meta[1]?.name || 'Value';
                                layer.bindPopup(`${columnName}: ${value}`);
                            }
                        }).addTo(map);
                        if (geoJsonLayer) {
                            geoJsonLayer.addLayer(layer);
                        } else {
                            geoJsonLayer = L.featureGroup([layer]);
                            geoJsonLayer.addTo(map);
                        }
                    });

                    // Fit map bounds to include all features
                    if (geoJsonLayer) {
                        map.fitBounds(geoJsonLayer.getBounds());
                    }
                } else if (data.meta.length === 1 && 
                    data.data.length > 0 && 
                    typeof data.data[0][0] === 'string' &&
                    (data.data[0][0].startsWith('{') || data.data[0][0].startsWith('['))) {
                    const features = data.data
                        .map(row => {
                            let geojson = JSON.parse(row[0]);
                            // Apply tessellation
                            if (geojson.type === 'Polygon' || geojson.type === 'LineString') {
                                geojson = tessellateGeometry(geojson);
                            } else if (geojson.type === 'Feature') {
                                if (geojson.geometry.type === 'Polygon' || geojson.geometry.type === 'LineString') {
                                    geojson.geometry = tessellateGeometry(geojson.geometry);
                                }
                            } else if (geojson.type === 'FeatureCollection') {
                                geojson.features = geojson.features.map(feature => {
                                    if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'LineString') {
                                        feature.geometry = tessellateGeometry(feature.geometry);
                                    }
                                    return feature;
                                });
                            }
                            return geojson;
                        })
                        .filter(geojson => geojson !== null);
                    
                    const featureCollection = {
                        type: 'FeatureCollection',
                        features: features.flatMap(geojson => {
                            if (geojson.type === 'FeatureCollection') {
                                return geojson.features;
                            }
                            return [geojson];
                        })
                    };

                    geoJsonLayer = L.geoJSON(featureCollection, {
                        style: {
                            color: '#088',
                            weight: 2,
                            opacity: 0.7,
                            fillOpacity: 0.4
                        }
                    }).addTo(map);
                }

                const layers = [...queryGeometryLayers];
                if (geoJsonLayer) layers.push(geoJsonLayer);
                
                if (layers.length > 0) {
                    const bounds = L.featureGroup(layers).getBounds();
                    map.fitBounds(bounds, { padding: [50, 50] });
                }

                map.invalidateSize();

                let table = '<table><thead><tr>';
                data.meta.forEach(col => {
                    table += `<th>${col.name}</th>`;
                });
                table += '</tr></thead><tbody>';

                data.data.forEach(row => {
                    table += '<tr>';
                    row.forEach(cell => {
                        const cellContent = typeof cell === 'object' ? 
                            JSON.stringify(cell) : (cell ?? 'NULL');
                        table += `<td>${cellContent}</td>`;
                    });
                    table += '</tr>';
                });
                table += '</tbody></table>';

                const stats = data.statistics;
                const statsHtml = `
                    <div class="stats">
                        <h3>Query Statistics</h3>
                        <p><strong>Elapsed Time:</strong> ${stats.elapsed}s</p>
                        <p><strong>Rows Read:</strong> ${stats.rows_read}</p>
                        <p><strong>Total Rows:</strong> ${data.rows_before_limit_at_least}</p>
                    </div>
                `;

                resultsDiv.innerHTML += table + statsHtml;
            } catch (error) {
                resultsDiv.innerHTML = `<p style="color: #ed262c; padding: 12px; background: #fff; border-radius: 4px; border: 1px solid #e1e4e8;">Error: ${error.message}</p>`;
            } finally {
                // Clear the timeout if it hasn't triggered yet
                clearTimeout(messageTimeout);
                
                // Reset button state
                executeButton.innerHTML = 'Execute Query';
                executeButton.disabled = false;
                loadingMessage.style.display = 'none';
            }
        }
    </script>
</body>
</html> 